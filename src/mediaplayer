#!/usr/bin/env python3
# Copyright 2023 Raffaele Mancuso
# SPDX-License-Identifier: MIT
# Inspired by: https://github.com/Alexays/Waybar/blob/master/resources/custom_modules/mediaplayer.py
# This requires `playerctl`: `sudo pacman -S playerctl`
# Call it like `mediaplayerctl --player player_name`
# Find player_name with `playerctl --list-all`
import argparse
import json
import logging
import math
import subprocess
import sys
import time

import gi
import requests

gi.require_version("Playerctl", "2.0")
from gi.repository import GLib, Playerctl

# Suppose that a song lasts 3 min
# and compute the time interval (in ms) corresponding to
# 1% of the song
# 3 min -> x/(3*60*1000) = 1%
refresh_interval = math.ceil((3 * 60 * 1000) / 100)
# logger.debug(f"Refresh interval (ms): {refresh_interval}")

# Set this to True if you want a notification when the song changes
notification = True
# Min interval between notifications, in seconds
# Avoids overflowing the notification bar in case you zap through songs
notification_min_interval = 2

# Widget width
# This must be the same as the min-length and max-length set in config file
widget_length = 20

# Minimum percentage change needed to update the progress bar
min_perc_update = 1

# Internal global variables
logger = logging.getLogger(__name__)
class_decs = 0
artfp = "/tmp/waybar-mediaplayer-art"
last_metadata = None
last_notification_time = 0
last_perc = None
# Whether refresh_interval callback is registered
is_refint = False


def on_player_appeared(manager, player, selected_player=None):
    logger.debug("I was called")
    if player is not None and (
        selected_player is None or player.name == selected_player
    ):
        init_player(manager, player)
    else:
        logger.debug("New player appeared, but it's not the selected player, skipping")

    logger.debug("Returning True")
    return True


def on_player_vanished(manager, player):
    logger.info("I was called")
    write_output()
    logger.info("Returning True")
    return True


def on_metadata(player, metadata, manager):
    logger.debug("I was called")
    update_metadata(player, metadata, manager)
    logger.debug("Returning True")
    return True


def on_playback_status(player, status, manager):
    logger.info("I was called")
    logger.debug(f"status={status}")
    # Update the icon in the progressbar (play/pause)
    logger.debug("Calling register_refresh_interval_callback")
    register_refresh_interval_callback(player, manager)
    logger.debug("Calling update_progressbar")
    update_progressbar(manager, player)
    logger.debug("Returning True")
    return True


def on_refresh_interval(manager):
    global is_refint
    logger.debug("I was called")
    # If there are no players, stop calling this handler
    if len(manager.props.players) == 0:
        logger.debug("Returning False")
        is_refint = False
        return False
    player = manager.props.players[0]
    # If we are not playing, stop calling this handler
    is_playing = player.props.status == "Playing"
    if not is_playing:
        logger.debug("Returning False")
        is_refint = False
        return False
    # Update progressbar and return
    update_progressbar(manager, player)
    logger.debug("Returning True")
    return True


def write_output(text="" + (" " * (widget_length - 1)), class_="0", tooltip=""):
    output = {"text": text, "class": class_, "tooltip": "<span>" + tooltip + "</span>"}
    sys.stdout.write(json.dumps(output) + "\n")
    sys.stdout.flush()


def register_refresh_interval_callback(player, manager):
    global is_refint
    logger.info("I was called")
    is_playing = player.props.status == "Playing"
    if is_playing and (not is_refint):
        logger.debug("Registering `refresh_interval` callback")
        GLib.timeout_add(refresh_interval, on_refresh_interval, manager)
        is_refint = True


def gen_widget_text(player):
    metadata = player.props.metadata
    artist = player.get_artist()
    # artist = metadata["xesam:artist"][0]
    title = player.get_title()
    # title = metadata["xesam:title"]

    if (
        player.props.player_name == "spotify"
        and "mpris:trackid" in metadata.keys()
        and ":ad:" in metadata["mpris:trackid"]
    ):
        text = "AD PLAYING"
    else:
        text = title

    if player.props.status != "Playing":
        text = " " + text
    else:
        text = " " + text

    text = left_text(text)
    return text


def update_metadata(player, metadata, manager):
    global last_notification_time
    logger.info("I was called")
    metadata = dict(metadata)
    # Update progressbar
    updated = update_progressbar(manager, player)
    if not updated:
        return False
    # Download album art
    if "mpris:artUrl" in metadata:
        logger.debug("Updating album art")
        art_url = metadata["mpris:artUrl"]
        resp = requests.get(art_url)
        with open(artfp, "wb") as fh:
            fh.write(resp.content)
            logger.debug(f"Album art '{art_url}' saved into '{artfp}'")
        # Update album art on bar
        cmd = ["pkill", "-RTMIN+2", "waybar"]
        subprocess.run(cmd)
    # Notification
    notexp = time.time() - last_notification_time
    if notification and notexp >= notification_min_interval:
        cmd = [
            "notify-send",
            "--app-name=waybar-mediaplayer",
            "--icon=" + artfp,
            player.get_title(),  # summary
            player.get_artist(),  # body
        ]
        logger.debug(f"Running {cmd}")
        subprocess.run(cmd)
        last_notification_time = time.time()
    logger.debug("Returning")


def left_text(s):
    l = len(s)
    if l > widget_length:
        return s
    missing = widget_length - l
    s = s + " " * (missing)
    return s


def center_text(s):
    ml = max([len(x) for x in s])
    for i in range(0, len(s)):
        delta = int((ml - len(s[i])) / 2)
        s[i] = (" " * delta) + s[i]
    return s


# Called
# 1. By `on_refresh_interval`
# 2. By `on_metadata`
# 3. By `on_playback_status`
def update_progressbar(manager, player):
    global last_metadata
    logger.debug("I was called")
    # Get percentage in the track
    pos = player.get_position()
    logger.debug(f"pos={pos}")
    # If it doesn't work, use CLI utility
    if pos == 0:
        cmd = ["playerctl", "--player=" + player.props.player_name, "position"]
        pos = subprocess.run(cmd, capture_output=True, text=True).stdout
        pos = float(pos) * (10**6)
        logger.debug(f"pos from CLI={pos}")
    pmetadata = player.props.metadata
    length = pmetadata["mpris:length"]
    logger.debug(f"length={length}")
    if length == 0:
        return False
    # Compute song percentage
    perc = round((pos / length) * 100, class_decs)
    metadata = {
        "title": player.get_title(),
        "artist": player.get_artist(),
        "album": player.get_album(),
        "pos": pos,
        "length": length,
        "perc": perc,
    }
    if metadata == last_metadata:
        return False
    # Check if percentage has not changed enough since last time
    if (
        last_metadata
        and metadata["title"] == last_metadata["title"]
        and metadata["artist"] == last_metadata["artist"]
        and metadata["album"] == last_metadata["album"]
        and metadata["length"] == last_metadata["length"]
        and metadata["perc"] > last_metadata["perc"] # we need to reset the bar if we restart the song
        and (metadata["perc"] - last_metadata["perc"]) < min_perc_update
    ):
        return False
    # Convert percentage in string
    if class_decs == 0:
        perc_str = str(int(perc))
    else:
        perc_str = str(perc).replace(".", "-")
    # Write output
    widget_text = gen_widget_text(player)
    s = [metadata["title"], metadata["artist"], metadata["album"]]
    center_text(s)
    tooltip = f"<span variant='title-caps' font_weight='bold'>{s[0]}</span>\n"
    tooltip += f"{s[1]}\n"
    tooltip += f"<i>{s[2]}</i>"
    # tooltip += f"<img src='" + artfp + "'></img>"
    write_output(widget_text, perc_str, tooltip)
    # It's important to return True to keep the handler going
    last_metadata = metadata
    logger.debug("Returning True")
    return True


def init_player(manager, name):
    logger.debug("I was called")
    logger.debug(f"name.name={name.name}")
    # Register handlers
    player = Playerctl.Player.new_from_name(name)
    player.connect("playback-status", on_playback_status, manager)
    player.connect("metadata", on_metadata, manager)
    manager.manage_player(player)
    # Call update_metadata to update progress bar and send notification
    logger.debug("Calling update_metadata")
    update_metadata(player, player.props.metadata, manager)
    # If we are playing, register refresh interval callback
    register_refresh_interval_callback(player, manager)
    logger.debug("Returning None")


def signal_handler(sig, frame):
    logger.debug("I was called")
    sys.stdout.write("\n")
    sys.stdout.flush()
    # loop.quit()
    sys.exit(0)


def parse_arguments():
    parser = argparse.ArgumentParser()
    # Increase verbosity with every occurrence of -v
    parser.add_argument("-v", "--verbose", action="count", default=0)
    # Define which player we're listening to
    # Find it with `playerctl --list-all`
    parser.add_argument("--player", required=True)
    return parser.parse_args()


def main():
    arguments = parse_arguments()

    # Initialize logging
    logging.basicConfig(
        stream=sys.stderr,
        level=logging.DEBUG,
        format="[%(funcName)s] [%(levelname)s] %(message)s",
    )

    # Logging is set by default to WARN and higher.
    # With every occurrence of -v it's lowered by one
    loglevel = max((3 - arguments.verbose) * 10, 0)
    logger.setLevel(loglevel)
    logging.getLogger("urllib3").setLevel(loglevel)

    # Log the sent command line arguments
    logger.info("I was called")
    logger.debug("Arguments received {}".format(vars(arguments)))

    manager = Playerctl.PlayerManager()
    loop = GLib.MainLoop()

    fn = lambda *args: on_player_appeared(*args, arguments.player)
    manager.connect("name-appeared", fn)
    manager.connect("player-vanished", on_player_vanished)

    # signal.signal(signal.SIGINT, signal_handler)
    # signal.signal(signal.SIGTERM, signal_handler)
    # signal.signal(signal.SIGPIPE, signal.SIG_DFL)

    ini = False
    for player in manager.props.player_names:
        logger.debug(f"Found player '{player.name}'")
        if arguments.player is not None and arguments.player != player.name:
            logger.debug("This is not the filtered player, skipping it")
            continue
        logger.debug("Initializing player")
        init_player(manager, player)
        ini = True

    if not ini:
        write_output()

    loop.run()


if __name__ == "__main__":
    main()
