#!/usr/bin/env python3
# Copyright 2023 Raffaele Mancuso
# SPDX-License-Identifier: MIT
# Inspired by: https://github.com/Alexays/Waybar/blob/master/resources/custom_modules/mediaplayer.py
# This requires `playerctl`: `sudo pacman -S playerctl`
# Call it like `mediaplayerctl --player player_name`
# Find player_name with `playerctl --list-all`
import argparse
import json
import logging
import math
import subprocess
import sys
import time
from pathlib import Path
from pprint import pprint

import gi
import requests

gi.require_version("Playerctl", "2.0")
from gi.repository import GLib, Playerctl


# Internal global variables
config = None
logger = logging.getLogger(__name__)
class_decs = 0
artfp = "/tmp/waybar-mediaplayer-art"
last_metadata = None
last_art_url = None
last_rot = 0
last_notification_time = 0
# Whether refresh_interval callback is registered
is_refint = False


def on_player_appeared(manager, player, selected_player=None):
    logger.debug("I was called")
    if player is not None and (
        selected_player is None or player.name == selected_player
    ):
        init_player(manager, player)
    else:
        logger.debug("New player appeared, but it's not the selected player, skipping")

    logger.debug("Returning True")
    return True


def on_player_vanished(manager, player):
    logger.info("I was called")
    write_output()
    logger.info("Returning True")
    return True


def on_metadata(player, metadata, manager):
    logger.debug("I was called")
    update_metadata(player, metadata, manager)
    logger.debug("Returning True")
    return True


def on_playback_status(player, status, manager):
    logger.info("I was called")
    logger.debug(f"status={status}")
    # Update the icon in the progressbar (play/pause)
    logger.debug("Calling register_refresh_interval_callback")
    register_refresh_interval_callback(player, manager)
    logger.debug("Calling update_progressbar")
    update_progressbar(manager, player)
    logger.debug("Returning True")
    return True


def on_refresh_interval(manager):
    global is_refint
    logger.debug("I was called")
    # If there are no players, stop calling this handler
    if len(manager.props.players) == 0:
        logger.debug("Returning False")
        is_refint = False
        return False
    player = manager.props.players[0]
    # If we are not playing, stop calling this handler
    is_playing = player.props.status == "Playing"
    if not is_playing:
        logger.debug("Returning False")
        is_refint = False
        return False
    # Update progressbar and return
    update_progressbar(manager, player)
    logger.debug("Returning True")
    return True


def write_output(text=None, class_="0", tooltip=""):
    global config
    if text is None:
        text = "" + (" " * (config["widget_length"] - 1))
    output = {"text": text, "class": class_, "tooltip": "<span>" + tooltip + "</span>"}
    sys.stdout.write(json.dumps(output) + "\n")
    sys.stdout.flush()


def register_refresh_interval_callback(player, manager):
    global is_refint
    logger.info("I was called")
    is_playing = player.props.status == "Playing"
    if is_playing and (not is_refint):
        logger.debug("Registering `refresh_interval` callback")
        GLib.timeout_add(config["refresh_interval"], on_refresh_interval, manager)
        is_refint = True


def rotate_str_left(s, rot):
    return s[rot:] + s[:rot]

def gen_widget_text(player):
    global last_rot
    metadata = player.props.metadata
    artist = player.get_artist()
    # artist = metadata["xesam:artist"][0]
    title = player.get_title()
    # title = metadata["xesam:title"]

    icon = " " if player.props.status != "Playing" else " "

    if (
        player.props.player_name == "spotify"
        and "mpris:trackid" in metadata.keys()
        and ":ad:" in metadata["mpris:trackid"]
    ):
        song_info = "AD PLAYING"
    else:
        song_info = title.strip()

    tl = len(icon) + len(song_info)

    if tl < config["widget_length"]:
        text = left_text(icon + song_info)
    else:
        song_info += " " + config["sepchar"] + " "
        l_rot = (last_rot + 1) % len(song_info)
        song_info = rotate_str_left(song_info, l_rot)
        text = icon + song_info
        last_rot = l_rot

    return text

def download_art(art_url):
    logger.debug("Updating album art")
    resp = requests.get(art_url)
    with open(artfp, "wb") as fh:
        fh.write(resp.content)
        logger.debug(f"Album art '{art_url}' saved into '{artfp}'")
    # Update album art on bar
    cmd = ["pkill", "-RTMIN+2", "waybar"]
    subprocess.run(cmd)

def send_notification(summary, body):
    global last_notification_time
    cmd = [
        "notify-send",
        "--app-name=waybar-mediaplayer",
        "--icon=" + artfp,
        summary,
        body
    ]
    logger.debug(f"Running {cmd}")
    subprocess.run(cmd)
    last_notification_time = time.time()

def update_metadata(player, metadata, manager):
    global last_notification_time, last_art_url
    logger.info("I was called")
    metadata = dict(metadata)
    # Update progressbar
    updated = update_progressbar(manager, player)
    if not updated:
        return False
    # Download album art
    art_url = metadata.get("mpris:artUrl", None)
    if art_url and art_url != last_art_url:
        download_art(art_url)
        last_art_url = art_url
    # Notification
    notexp = time.time() - last_notification_time
    if config["is_notification"] and notexp >= config["notification_min_interval"]:
        send_notification(player.get_title(), player.get_artist())
    logger.debug("Returning")


def left_text(s):
    l = len(s)
    if l > config["widget_length"]:
        return s
    missing = config["widget_length"] - l
    s = s + " " * (missing)
    return s


def center_text(s):
    ml = max([len(x) for x in s])
    for i in range(0, len(s)):
        delta = int((ml - len(s[i])) / 2)
        s[i] = (" " * delta) + s[i]
    return s


# Called
# 1. By `on_refresh_interval`
# 2. By `on_metadata`
# 3. By `on_playback_status`
def update_progressbar(manager, player):
    global last_metadata
    logger.debug("I was called")
    # Get percentage in the track
    pos = player.get_position()
    logger.debug(f"pos={pos}")
    # If it doesn't work, use CLI utility
    if pos == 0:
        cmd = ["playerctl", "--player=" + player.props.player_name, "position"]
        pos = subprocess.run(cmd, capture_output=True, text=True).stdout
        pos = float(pos) * (10**6)
        logger.debug(f"pos from CLI={pos}")
    pmetadata = player.props.metadata
    length = pmetadata["mpris:length"]
    logger.debug(f"length={length}")
    if length == 0:
        return False
    # Compute song percentage
    perc = round((pos / length) * 100, class_decs)
    metadata = {
        "title": player.get_title(),
        "artist": player.get_artist(),
        "album": player.get_album(),
        "pos": pos,
        "length": length,
        "perc": perc,
    }
    if metadata == last_metadata:
        return False
    # Check if percentage has not changed enough since last time
    diff = metadata["perc"] - last_metadata["perc"] if last_metadata else None
    if (
        last_metadata
        and metadata["title"] == last_metadata["title"]
        and metadata["artist"] == last_metadata["artist"]
        and metadata["album"] == last_metadata["album"]
        and metadata["length"] == last_metadata["length"]
        and diff >= 0 # we need to reset the bar if we restart the song
        and diff < config["min_perc_update"]
    ):
        return False
    # Convert percentage in string
    if class_decs == 0:
        perc_str = str(int(perc))
    else:
        perc_str = str(perc).replace(".", "-")
    # Write output
    widget_text = gen_widget_text(player)
    s = [metadata["title"], metadata["artist"], metadata["album"]]
    center_text(s)
    tooltip = f"<span variant='title-caps' font_weight='bold'>{s[0]}</span>\n"
    tooltip += f"{s[1]}\n"
    tooltip += f"<i>{s[2]}</i>"
    # tooltip += f"<img src='" + artfp + "'></img>"
    write_output(widget_text, perc_str, tooltip)
    # It's important to return True to keep the handler going
    last_metadata = metadata
    logger.debug("Returning True")
    return True


def init_player(manager, name):
    logger.debug("I was called")
    logger.debug(f"name.name={name.name}")
    # Register handlers
    player = Playerctl.Player.new_from_name(name)
    player.connect("playback-status", on_playback_status, manager)
    player.connect("metadata", on_metadata, manager)
    manager.manage_player(player)
    # Call update_metadata to update progress bar and send notification
    logger.debug("Calling update_metadata")
    update_metadata(player, player.props.metadata, manager)
    # If we are playing, register refresh interval callback
    register_refresh_interval_callback(player, manager)
    logger.debug("Returning None")


def signal_handler(sig, frame):
    logger.debug("I was called")
    sys.stdout.write("\n")
    sys.stdout.flush()
    # loop.quit()
    sys.exit(0)


def parse_arguments():
    parser = argparse.ArgumentParser()
    # Increase verbosity with every occurrence of -v
    parser.add_argument("-v", "--verbose", action="count", default=0)
    # Define which player we're listening to
    # Find it with `playerctl --list-all`
    parser.add_argument("--player", required=True)
    return parser.parse_args()


def main():
    arguments = parse_arguments()

    # Initialize logging
    logging.basicConfig(
        stream=sys.stderr,
        level=logging.DEBUG,
        format="[%(funcName)s] [%(levelname)s] %(message)s",
    )

    # Logging is set by default to WARN and higher.
    # With every occurrence of -v it's lowered by one
    # until it reaches 0
    loglevel = max((3 - arguments.verbose) * 10, 0)
    logger.setLevel(loglevel)
    logging.getLogger("urllib3").setLevel(loglevel)

    # Log the sent command line arguments
    logger.info("I was called")
    logger.debug("Arguments received {}".format(vars(arguments)))

    # Read configuration from file
    fp = Path(sys.argv[0]).parent.resolve() / "config.json"
    if not fp.is_file():
        logging.critical(f"ERROR: Configuration file {fp} not found")
        sys.exit(1)
    with open(fp, "r") as fh:
        global config
        config = json.load(fh)
    assert(type(config)==dict)

    manager = Playerctl.PlayerManager()
    loop = GLib.MainLoop()

    fn = lambda *args: on_player_appeared(*args, arguments.player)
    manager.connect("name-appeared", fn)
    manager.connect("player-vanished", on_player_vanished)

    # signal.signal(signal.SIGINT, signal_handler)
    # signal.signal(signal.SIGTERM, signal_handler)
    # signal.signal(signal.SIGPIPE, signal.SIG_DFL)

    ini = False
    for player in manager.props.player_names:
        logger.debug(f"Found player '{player.name}'")
        if arguments.player is not None and arguments.player != player.name:
            logger.debug("This is not the filtered player, skipping it")
            continue
        logger.debug("Initializing player")
        init_player(manager, player)
        ini = True

    if not ini:
        write_output()

    loop.run()


if __name__ == "__main__":
    main()
